# Snippets common to C++ header/implementation files

global !p
from ultisnips_util import *

# Return the file header for the specified package and component in a header
# file
def fileHeader_h(package, component):
	comp = "// " + package + "_" + component.lower() + ".h"
	firstLine = comp + rightAlign(79 - len(comp), "-*-C++-*-")

	guard = "INCLUDED_" + package.upper() + "_" + component.upper()

	template = """$firstLine
#ifndef $guard
#define $guard

//@PURPOSE: TODO
//
//@CLASSES:
// """ + package + "::" + component + """
//
//@SEE_ALSO:
//
//@DESCRIPTION: TODO

namespace BloombergLP {"""

	return string.Template(template).safe_substitute({
		"firstLine": firstLine,
		"guard":guard
	})

# Return the file footer
def fileFooter_h():
	return """}  // close package namespace
}  // close enterprise namespace

#endif

""" + copyright()

# Return the file header for the specified package and component for a cpp
# file
def fileHeader_cpp(package, component):
    comp = "// " + package + "_" + component.lower() + ".cpp"
    firstLine = comp + rightAlign(79 - len(comp), "-*-C++-*-")

    guard = "INCLUDED_" + package.upper() + "_" + component.upper()

    template = string.Template("""$firstLine
#include <${package}_${component}.h>

namespace BloombergLP {""")

    return template.safe_substitute({"firstLine": firstLine,
                                     "package": package.lower(),
                                     "component": component.lower()})

# Return the file footer
def fileFooter_cpp():
    return """}  // close package namespace
}  // close enterprise namespace

""" + copyright()

def genTabStopPrePost(preText, tabStopNum, defaultVal, postText):
	"""
	Generate some python to produce a tabstop with some text before, and some
	text after the tabstop if the tabstop isn't empty
	"""

	ret = ""

	# Pre text
	if len(preText) > 0:
		ret += "`!p snip.rv = '" + preText + "' " + \
				"if len(t[" + str(tabStopNum) + "]) > 0 else ''`";

	# Tab stop
	if defaultVal and len(defaultVal) > 0:
		ret += "${" + str(tabStopNum) + ":" + defaultVal + "}"
	else:
		ret += "$" + str(tabStopNum)

	# Post text
	if len(postText) > 0:
		ret += "`!p snip.rv = '" + postText + "' " + \
				"if len(t[" + str(tabStopNum) + "]) > 0 else ''`";

	return ret

def genInitMemSnippet(snip, delimiter, deleteDelimiter, initDataFn):
	"""
	Create a snippet for the initialization of class member variables in a
	constructor.  Using the specified 'snip' object, the specified 'delimiter'
	to determine when the list of variables has ended, the specified
	'deleteDelimiter' to determine whether the delimiter should be deleted,
	and the specified initDataFn to determine how the member should be
	initialized.  'initDataFn' is called with the member being initialized,
	and the current snippet tab number.
	"""

	# Search up for either 'basicAllocator' or 'allocator'
	allocName = ""
	for l in range(snip.line, 0, -1):
		if re.match(r'.*\bbasicAllocator\b', snip.buffer[l]):
			allocName = "basicAllocator"
			break
		elif re.match(r'.*\ballocator\b', snip.buffer[l]):
			allocName = "allocator"
			break
		elif len(snip.buffer[l].strip()) == 0:
			break

	# If line above snip.line starts with ', ' or ': ' then we'll start with
	# ', ', otherwise we'll start with ': '
	prevLine = snip.buffer[snip.line - 1].strip()
	startSeparator = ", " if (prevLine.startswith(": ") or
							  prevLine.startswith(", ")) else \
					 ": "

	retLines = []
	snipNum = 2
	while snip.buffer[snip.line].strip() != delimiter:
		l = snip.buffer[snip.line]

		snipLine = ("$1" + startSeparator) if snipNum == 2 else ", "
		snipLine += l + "(" + initDataFn(l, snipNum)
		snipNum += 1

		# Gen optional allocator for each member if constructor took an
		# allocator
		if len(allocName) > 0:
			allocString = genTabStopPrePost(", ", snipNum, allocName, "")
			#allocString = ("${%d:, " + allocName + "}") % snipNum
			snipNum += 1

			snipLine += allocString

			snipLine += ")"

		retLines.append(snipLine)

		del snip.buffer[snip.line]

	if deleteDelimiter:
		del snip.buffer[snip.line]

	retLines.append("")
	snip.expand_anon("\n".join(retLines))

def findClassName(snip):
	"""
	Search up looking for a class/struct section name, and return the class
	name if found, otherwise return None.  A section name looks like
	// ---------- (or ======)
	// class Foo
	// ---------
	"""

	pattern = re.compile(r'^ *// (?:class|struct) (.*)')
	for line in range(snip.line, 0, -1):
		match = pattern.match(snip.buffer[line])
		if (match):
			return match.group(1)

	return None

def cleanupMembers(decl):
	"""Cleanup the specified member variable declaration 'decl
	'' by removing all comments and types and leaving just member names
	without semicolons."""

	# Remove comments
	mems = re.sub(r'//.*', '', decl)

	# Remove empty
	mems = re.sub(r'\n\s*\n', '\n', mems, 0, re.MULTILINE)

	# Remove declarations/semicolon
	mems = "\n".join(
		[re.sub(r'.*[ *&]([^ *&]*);.*', r'\1', l) \
			for l in mems.split('\n')[:-1]])

	return mems

def clearSnipLine(snip):
	"""
	Clear the current line of the specified 'snip' and set the current
	position to the beginning of it.
	"""
	snip.buffer[snip.line] = ""
	snip.cursor.set(snip.line, 0)

def appendToSnip(snip, s):
	"""
	Append the specified 's' to the end of the current line of the specified
	'snip', separating it from anything previous on the line with a ','
	"""

	if len(snip.buffer[snip.line]) > 0:
		snip.buffer[snip.line] += ", "

	snip.buffer[snip.line] += s

endglobal

                                   # #####
                                   # cctor
                                   # #####

pre_expand "clearSnipLine(snip);appendToSnip(snip, findClassName(snip))"
post_jump "if snip.tabstop == 0: genInitMemSnippet(snip, '{', False, lambda mem, snip: 'other.' + mem)"
snippet cctor
$1::$1(const $1& other, ${2:bslma::Allocator *basicAllocator = 0})
$0`!p snip.rv = cleanupMembers(snip.v.text)`
{
}
endsnippet

                                  # #######
                                  # ctormem
                                  # #######

pre_expand "clearSnipLine(snip)"
post_jump "if snip.tabstop == 0: genInitMemSnippet(snip, '---', True, lambda mem, snipNum: '$%d' % snipNum)"
snippet ctormem
$0`!p snip.rv = cleanupMembers(snip.v.text)`
---
endsnippet




snippet inc "C include directive" b
#include <$1.h>
endsnippet

snippet class
`!p snip.rv = centerBorder("=", "class " + t[1])`
`!p snip.rv = centerPadding("// class " + t[1]) + "// class "`$1
`!p snip.rv = centerBorder("=", "class " + t[1])`

`!p snip.rv = classDef(t[1])`
endsnippet

snippet classh
`!p snip.rv = fileHeader_h(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("=", "class " + t[2])`
`!p snip.rv = centerPadding("// class " + t[2]) + "// class "`$2
`!p snip.rv = centerBorder("=", "class " + t[2])`

`!p snip.rv = classDef(t[2])`

`!p snip.rv = fileFooter_h()`
endsnippet

snippet classcpp
`!p snip.rv = fileHeader_cpp(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("-", "class " + t[2])`
`!p snip.rv = centerPadding("// class " + t[2]) + "// class "`$2
`!p snip.rv = centerBorder("-", "class " + t[2])`

`!p snip.rv = fileFooter_cpp()`
endsnippet

snippet struct
`!p snip.rv = centerBorder("=", "struct " + t[1])`
`!p snip.rv = centerPadding("// struct " + t[1]) + "// struct "`$1
`!p snip.rv = centerBorder("=", "struct " + t[1])`

`!p snip.rv = structDef(t[1])`
endsnippet

snippet util
`!p snip.rv = centerBorder("=", "struct " + t[1])`
`!p snip.rv = centerPadding("// struct " + t[1]) + "// struct "`$1
`!p snip.rv = centerBorder("=", "struct " + t[1])`

`!p snip.rv = utilDef(t[1])`
endsnippet

snippet utilh
`!p snip.rv = fileHeader_h(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("=", "struct " + t[2])`
`!p snip.rv = centerPadding("// struct " + t[2]) + "// struct "`$2
`!p snip.rv = centerBorder("=", "struct " + t[2])`

`!p snip.rv = utilDef(t[2])`

`!p snip.rv = fileFooter_h()`
endsnippet

snippet utilcpp
`!p snip.rv = fileHeader_cpp(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("-", "struct " + t[2])`
`!p snip.rv = centerPadding("// struct " + t[2]) + "// struct "`$2
`!p snip.rv = centerBorder("-", "struct " + t[2])`

`!p snip.rv = fileFooter_cpp()`
endsnippet

snippet protocol
`!p snip.rv = centerBorder("=", "class " + t[1])`
`!p snip.rv = centerPadding("// class " + t[1]) + "// class "`$1
`!p snip.rv = centerBorder("=", "class " + t[1])`

`!p snip.rv = protocolDef(t[1])`
endsnippet

snippet protocolh
`!p snip.rv = fileHeader_h(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("=", "class " + t[2])`
`!p snip.rv = centerPadding("// class " + t[2]) + "// class "`$2
`!p snip.rv = centerBorder("=", "class " + t[2])`

`!p snip.rv = protocolDef(t[2])`

`!p snip.rv = fileFooter_h()`
endsnippet

snippet protocolcpp
`!p snip.rv = fileHeader_cpp(t[1], t[2])`
namespace $1 {

`!p snip.rv = centerBorder("-", "class " + t[2])`
`!p snip.rv = centerPadding("// class " + t[2]) + "// class "`$2
`!p snip.rv = centerBorder("-", "class " + t[2])`

// CREATORS
$2::~$2()
{
}

`!p snip.rv = fileFooter_cpp()`
endsnippet

snippet enum
`!p snip.rv = centerBorder("=", "struct " + t[1])`
`!p snip.rv = centerPadding("// struct " + t[1]) + "// struct "`$1
`!p snip.rv = centerBorder("=", "struct " + t[1])`

`!p snip.rv = enumDef(t[1])`
endsnippet

snippet pod
`!p snip.rv = header("=", "class " + t[1])`

struct $1 {
	// TODO

	// DATA
};

endsnippet

snippet test_case "test case" m
case $1: {
  // --------------------------------------------------------------------
  // $2
  //
  // Concerns:
  //  a) $0
  //
  // Plan:
  //  1)
  //
  // Testing:
  // --------------------------------------------------------------------

  if (verbose) cout << endl
                    << "$2" << endl
`!p snip.rv = "                    << \"" + "="*len(t[2]) + "\" << endl;"`

} break;
endsnippet


snippet inline
// ============================================================================
//                      INLINE AND TEMPLATE FUNCTION IMPLEMENTATIONS
// ============================================================================

$0
endsnippet

snippet tester
                               // ============
                               // class Tester
                               // ============

class Tester {
    // Helper class testing $1, wrapping its creation and
    // providing convenient wrappers for calling its functions and checking
    // its results.
    //
    // Many of the functions take a 'int line' argument, which is always
    // passed 'L_' and is used in assertion messages to find where an error
    // occurred.

    // DATA
    bslma::Allocator      *d_allocator_p
    bslma::ManagedPtr<$1>  d_object;

    // PRIVATE MANIPULATORS
    void destroy();
    	// Destroy the object being tested and reset all supporting objects.

    // NOT IMPLEMENTED
    Tester(const Tester&);
    Tester& operator=(const Tester&);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Tester,
    							   bslma::UsesBslmaAllocator);

    // CREATORS
    explicit Tester(bslma::Allocator *basicAllocator = 0);
	~Tester();

    // MANIPULATORS
    void init(int line);
        // (Re-)create the object being tested and reset the state of any
        // supporting objects.

    $1& object();
        // Return a reference providing modifiable access to the object being
        // tested.

};

                               // ------------
                               // class Tester
                               // ------------

// PRIVATE MANIPULATORS
void Tester::destroy()
{
    d_object.reset();
}

// CREATORS
Tester::Tester(bslma::Allocator *basicAllocator)
: d_allocator_p(bslma::Default::allocator(basicAllocator))
, d_object()
{
}

Tester::Tester()
{
	destroy();
}

// MANIPULATORS
void Tester::init(int line)
{
    d_object.load(new (*d_allocator_p) $1(d_allocator_p),
                  d_allocator_p);
}

$1& Tester::object()
{
    return *d_object;
}

endsnippet
